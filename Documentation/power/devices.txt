Device Power Management
장치 전력 관리

Copyright (c) 2010-2011 Rafael J. Wysocki <rjw@sisk.pl>, Novell Inc.
Copyright (c) 2010 Alan Stern <stern@rowland.harvard.edu>


Most of the code in Linux is device drivers, so most of the Linux power
management (PM) code is also driver-specific.  Most drivers will do very
little; others, especially for platforms with small batteries (like cell
phones), will do a lot.

Linux의 대부분의 코드는 device driver 이다, 그래서 대부분의 Linux power management 
(PM) 코드 역시 driver-specific 하다. 대부분은 거의 적을 것이고, 나머지들, 특히 
(휴대폰과 같이) 작은 배터리를 가진 플랫폼들은 많을 것이다.

This writeup gives an overview of how drivers interact with system-wide
power management goals, emphasizing the models and interfaces that are
shared by everything that hooks up to the driver model core.  Read it as
background for the domain-specific work you'd do with any specific driver.

이 문서는 어떻게 driver 들이 시스템 전반의 power management 목표와 상호작용 하는지에 대한 
overview를 드릴것이며, 특히 driver 모델 코어에 연결되는 모델과 interface들에 중점을 둔다. 
어떤 특정 driver에 일하든  domain-specific 한 업무에 대한 background로서 읽으면 되겠다.


Two Models for Device Power Management
장치 전력 관리를 위한 두 가지 모델
======================================
Drivers will use one or both of these models to put devices into low-power
states:

Driver들은 장치를 저전력 상태로 만들기 위해 하나 혹은 두가지 모두의 모델을 사용할 것입니다:

    System Sleep model:
    시스템 슬립 모델:
	Drivers can enter low-power states as part of entering system-wide
	low-power states like "suspend" (also known as "suspend-to-RAM"), or
	(mostly for systems with disks) "hibernation" (also known as
	"suspend-to-disk").

	Driver 들은 "suspend" ("suspend-to-RAM"으로 알려진)나, (디스크를 가진 시스템의 
	대부분에 해당하는) "hibernation" ("suspend-to-disk"로 알려진) 과 같은 시스템 상
	(system-wide)의 저전력 상태에 진입하는 일부의 저전력 상태로 진입할 수 있다.

	This is something that device, bus, and class drivers collaborate on
	by implementing various role-specific suspend and resume methods to
	cleanly power down hardware and software subsystems, then reactivate
	them without loss of data.

	이것은, device, bus, 그리고 class driver 가  하드웨어와 소프트웨어 subsystem들을 
	깔끔하게 끄고, 데이터 손실없이 재활성시키는 여러가지 role-specific한 suspend 와 
	resume 방법을 구현함으로 연동되는 것들입니다.

	Some drivers can manage hardware wakeup events, which make the system
	leave the low-power state.  This feature may be enabled or disabled
	using the relevant /sys/devices/.../power/wakeup file (for Ethernet
	drivers the ioctl interface used by ethtool may also be used for this
	purpose); enabling it may cost some power usage, but let the whole
	system enter low-power states more often.

	어떤 driver들은 하드웨어 wakeup 이벤트를 관리할 수 있는데, 이것은 시스템을 저전력 
	상태로 놔둘 수 있습니다. 이 feature는 /sys/devices…/power/wakeup 파일과 관련된 
	것들을 사용해서 enable하거나 disable 시킬 수 있다; 이걸 enable 시키는게 전력을 
	사용할 수도 있지만, 전체 시스템이 훨씬 자주 저전력 상태로 진입하게끔 한다.

    Runtime Power Management model:
    런타임 전력 관리 모델:
	Devices may also be put into low-power states while the system is
	running, independently of other power management activity in principle.
	However, devices are not generally independent of each other (for
	example, a parent device cannot be suspended unless all of its child
	devices have been suspended).  Moreover, depending on the bus type the
	device is on, it may be necessary to carry out some bus-specific
	operations on the device for this purpose.  Devices put into low power
	states at run time may require special handling during system-wide power
	transitions (suspend or hibernation).

	장치들은 시스템이 동작중인 동안, 대체적인 다른 전력 관리과 독립적으로, 저전력 상태에 들어갈 
	수 있다. 그러나, 장치들은 보통 서로 독립적이지 않다. 더군다나, bus type에 따라선 장치가 
	켜져 있으면, 이 목적을 위해 어떤 bus-specific 한 동작들을 해당 장치에 맞게 구현할 필요가 
	있다. runtime에 장치를 저전력 상태로 만드는 것은 시스템 전반의 파워 변화(suspend 혹은 
	hibernation시)에 특별한 handling이 필요할 수 있다. 

	For these reasons not only the device driver itself, but also the
	appropriate subsystem (bus type, device type or device class) driver and
	the PM core are involved in runtime power management.  As in the system
	sleep power management case, they need to collaborate by implementing
	various role-specific suspend and resume methods, so that the hardware
	is cleanly powered down and reactivated without data or service loss.

	이 때문에 device driver 자체 뿐만 아니라, 적절한 subsystem (bus type, devce 
	type, 혹은 device class) driver 와 PM core 가 runtime power management에 
	포함된다. 시스템 sleep power management 경우에서 처럼, 위의 것들이 여러가지 
	role-specific한 suspend 와 resume 방법을 구현함으로서 연동하는 것이 필요하며, 
	그리하여 하드웨어가 데이터나 서비스의 유실 없이 깔끔하게 꺼지고 켜질 수 있다.

There's not a lot to be said about those low-power states except that they are
very system-specific, and often device-specific.  Also, that if enough devices
have been put into low-power states (at runtime), the effect may be very similar
to entering some system-wide low-power state (system sleep) ... and that
synergies exist, so that several drivers using runtime PM might put the system
into a state where even deeper power saving options are available.

이것들이 매우 system-specific 하고 device-specific 하다는 것을 제외하고는 이 저전력 상태에 
대해 말할게 많지 않다. 또한 (runtime 시) 충분한 장치들이 저전력 상태에 있다고 한다면, 효과도 매우 
비슷하다는 것도…

Most suspended devices will have quiesced all I/O: no more DMA or IRQs (except
for wakeup events), no more data read or written, and requests from upstream
drivers are no longer accepted.  A given bus or platform may have different
requirements though.

대부분의 suspended 장치들은 모든 I/O에 대해 거부될 것입니다: DMA나 IRQ(Wakeup 이벤트를 
제외한), 데이터 읽기 혹은 쓰기, 그리고 상위 driver로부터의 요청들이 더이상 받아지지 않습니다. 

Examples of hardware wakeup events include an alarm from a real time clock,
network wake-on-LAN packets, keyboard or mouse activity, and media insertion
or removal (for PCMCIA, MMC/SD, USB, and so on).

하드웨어 wakeup 이벤트의 예는 real time clock, network wake-on-LAN 패킷, 키보드 혹은 
마우스 동작, 그리고 미디어 장치의 삽입/해제 (PCMCIA, MMC/SD, USB 등) 이 포함 되겠습니다.


Interfaces for Entering System Sleep States
시스템 슬립 상태에 들어가기 위한 인터페이스
===========================================
There are programming interfaces provided for subsystems (bus type, device type,
device class) and device drivers to allow them to participate in the power
management of devices they are concerned with.  These interfaces cover both
system sleep and runtime power management.

전력 관리에 포함되도록 허락하기 위해 Subsystem (bus type, device type, device class)들과 
device driver들에게 제공되는 프로그래밍 interface들이 있습니다.


Device Power Management Operations
장치 전력 관리 오퍼레이션
----------------------------------
Device power management operations, at the subsystem level as well as at the
device driver level, are implemented by defining and populating objects of type
struct dev_pm_ops:

Subsystem 레벨 및 device driver 레벨에서의 장치 전력 관리 operation 들은 struct 
dev_pm_ops 타입의 object를 정의하고 거주함으로써 구현 됩니다:

struct dev_pm_ops {
	int (*prepare)(struct device *dev);
	void (*complete)(struct device *dev);
	int (*suspend)(struct device *dev);
	int (*resume)(struct device *dev);
	int (*freeze)(struct device *dev);
	int (*thaw)(struct device *dev);
	int (*poweroff)(struct device *dev);
	int (*restore)(struct device *dev);
	int (*suspend_late)(struct device *dev);
	int (*resume_early)(struct device *dev);
	int (*freeze_late)(struct device *dev);
	int (*thaw_early)(struct device *dev);
	int (*poweroff_late)(struct device *dev);
	int (*restore_early)(struct device *dev);
	int (*suspend_noirq)(struct device *dev);
	int (*resume_noirq)(struct device *dev);
	int (*freeze_noirq)(struct device *dev);
	int (*thaw_noirq)(struct device *dev);
	int (*poweroff_noirq)(struct device *dev);
	int (*restore_noirq)(struct device *dev);
	int (*runtime_suspend)(struct device *dev);
	int (*runtime_resume)(struct device *dev);
	int (*runtime_idle)(struct device *dev);
};

This structure is defined in include/linux/pm.h and the methods included in it
are also described in that file.  Their roles will be explained in what follows.
For now, it should be sufficient to remember that the last three methods are
specific to runtime power management while the remaining ones are used during
system-wide power transitions.

이 구조체는 include/linux/pm.h에 정의돼 있고 method들도 해당 파일 내에 기술돼 있습니다. 그 역할
에 대해서는 앞으로 설명 드리겠습니다. 일단, 끝의 세 개 method 들은 runtime power management에 
한정적이지만, 반면에 나머지들은 시스템 전체 파워 전이 시 쓰입니다. 

There also is a deprecated "old" or "legacy" interface for power management
operations available at least for some subsystems.  This approach does not use
struct dev_pm_ops objects and it is suitable only for implementing system sleep
power management methods.  Therefore it is not described in this document, so
please refer directly to the source code for more information about it.

적어도 특정 subsystem들을 위해 가능한 전력 관리를 위한 오래된 interface 들도 있습니다. 이런 접근법
들은 struct dev_pm_ops 오브젝트를 쓰지 않으며 시스템 sleep 전력 관리 method를 위해 적합합니다. 
그러므로 이런 것들은 이 문서에서 기술하지 않으며, 그래서 이후의 정보를 보시려면 소스 코드를 바로 참조하
세요.

Subsystem-Level Methods
-----------------------
The core methods to suspend and resume devices reside in struct dev_pm_ops
pointed to by the ops member of struct dev_pm_domain, or by the pm member of
struct bus_type, struct device_type and struct class.  They are mostly of
interest to the people writing infrastructure for platforms and buses, like PCI
or USB, or device type and device class drivers.  They also are relevant to the
writers of device drivers whose subsystems (PM domains, device types, device
classes and bus types) don't provide all power management methods.

struct dev_pm_ops 내에 장치를 suspend와 resume 하기 위한 Core method들은 struct 
dev_pm_domain 타입이나 혹은, struct bus_type, struct device_type 그리고 struct class의 
pm 멤버에 의해 가리킨다. 이들은 대부분 PCI나 USB, 혹은 device type 과 device class driver 
와 같은 플랫폼이나 bus와 같은 infrastructure를 만드는 사람들에의한 흥미에 의한 것이다. 이것들은 또
한 subsystem이 모든 전력관리 method들을 제공하지 않은 device driver의 작성자와도 관련이 있다.

Bus drivers implement these methods as appropriate for the hardware and the
drivers using it; PCI works differently from USB, and so on.  Not many people
write subsystem-level drivers; most driver code is a "device driver" that builds
on top of bus-specific framework code.

Bus driver는 하드웨어와 그것을 사용하는 driver에 적합하도록 이러한 method를 구현한다; (예를 들면) 
PCI는 USB와 다르게 동작한다던지. 많지 않은 사람들이 subsystem-level의 driver를 작성한다; 대부분
의 driver 코드는 bus-specific 한 프래임워크 코드의 상위에 빌드되는 "device driver" 이다.

For more information on these driver calls, see the description later;
they are called in phases for every device, respecting the parent-child
sequencing in the driver model tree.

이러한 driver 호출에 대한 보다 많은 정보들은, 다음 서술을 보시라; 이들은 모든 장치를 위한 모든 측면에
서 호출 되며, 이러한 것들은 driver모델 트리 내 부모-자식 순서와 관련 있다.

/sys/devices/.../power/wakeup files
-----------------------------------
All device objects in the driver model contain fields that control the handling
of system wakeup events (hardware signals that can force the system out of a
sleep state).  These fields are initialized by bus or device driver code using
device_set_wakeup_capable() and device_set_wakeup_enable(), defined in
include/linux/pm_wakeup.h.

드라이버 모델에서 모든 장치 오브젝트들은 시스템 wakeup 이벤트(시스템을 sleep 상태에서 깨어나게하는 
하드웨어 시그널)의 핸들링을 제어하는 필드를 포함한다. 이런 필드들은 버스나, 
include/linux/pm_wakeup.h에 정의된, device_set_wakeup_cable(), 
device_set_wakeup_enable() 을 사용하는 device driver에 의해 초기화 된다.

The "power.can_wakeup" flag just records whether the device (and its driver) can
physically support wakeup events.  The device_set_wakeup_capable() routine
affects this flag.  The "power.wakeup" field is a pointer to an object of type
struct wakeup_source used for controlling whether or not the device should use
its system wakeup mechanism and for notifying the PM core of system wakeup
events signaled by the device.  This object is only present for wakeup-capable
devices (i.e. devices whose "can_wakeup" flags are set) and is created (or
removed) by device_set_wakeup_capable().

"power.can_wakeup" 플래그는 다순히 장치(와 드라이버)가 물리적으로 wakeup 이벤트를 지원하는지 
여부를 기록합니다. "power.wakeup" 필드는 장치가 시스템 wakeup 메커니즘을 써야하는지 아닌지를 
컨트롤 하기 위해, 그리고 PM 코어에게 장치에 의해 signal된 wakeup 이벤트를 알려주기 위해 쓰이는 
struct wakeup_source 타입의 오브젝트에 대한 포인터 입니다. 이 오브젝트는 wakeup-가능한 장치를 
위해 존재하며 device_set_wakeup_cable() 에 의해 생성됩니다.

Whether or not a device is capable of issuing wakeup events is a hardware
matter, and the kernel is responsible for keeping track of it.  By contrast,
whether or not a wakeup-capable device should issue wakeup events is a policy
decision, and it is managed by user space through a sysfs attribute: the
"power/wakeup" file.  User space can write the strings "enabled" or "disabled"
to it to indicate whether or not, respectively, the device is supposed to signal
system wakeup.  This file is only present if the "power.wakeup" object exists
for the given device and is created (or removed) along with that object, by
device_set_wakeup_capable().  Reads from the file will return the corresponding
string.

장치가 wakeup 이벤트를 발생시킬수 있는지 없는지는 하드웨어 문제이며, 커널은 이걸 간직할 책임이 있습니
다. 반대로, wakeup 가능한 장치가 wakeup 이벤트를 발생시켜야 하냐마냐는 정책 결정이며, 이것은 
sysfs attribute를 통해 user space 에서 관리됩니다: "power/wakeup" 파일. User space 는, 
각각, 시스템 wakeup을 지원하는지 아닌지를 지시하기 위해 "enable" 이나 "disabled"를 쓸 수 있습니
다. 이 파일은 오직 "power.wakeup" 오브젝트가 주어진 장치에 있으면 존재하며 
device_set_wakeup_capable()에 의해 그 오브젝트와 함께 생성됩니다(혹은 소멸됩니다). 이 파일을 
읽으면 해당되는 문자열이 리턴됩니다.

The "power/wakeup" file is supposed to contain the "disabled" string initially
for the majority of devices; the major exceptions are power buttons, keyboards,
and Ethernet adapters whose WoL (wake-on-LAN) feature has been set up with
ethtool.  It should also default to "enabled" for devices that don't generate
wakeup requests on their own but merely forward wakeup requests from one bus to
another (like PCI Express ports).

"power/wakeup" 파일은 대부분의 장치들을 위해 초기시에 "disabled" 문자열을 포함하도록 되어 있습니
다; 파워 버튼, 키보드 그리고 WoL (wake-on-LAN) feature이 ethtool로 셋업되어온 이더넷 어댑터는 
주요 예외입니다. (PCI Express 포트와 같이) wakeup 요청을 특정 bus에서 다른 쪽으로 넘갸주지 못하거
나 스스로 Wakeup 요청을 발생시키지 못하는 장치들에 대해서도 디폴트 "enabled"이어야 합니다.

The device_may_wakeup() routine returns true only if the "power.wakeup" object
exists and the corresponding "power/wakeup" file contains the string "enabled".
This information is used by subsystems, like the PCI bus type code, to see
whether or not to enable the devices' wakeup mechanisms.  If device wakeup
mechanisms are enabled or disabled directly by drivers, they also should use
device_may_wakeup() to decide what to do during a system sleep transition.
Device drivers, however, are not supposed to call device_set_wakeup_enable()
directly in any case.

device_may_wakeup() 루틴은 "power.wakeup" 오브젝트가 존재하고 "power/wakeup"파일이 
"enabled" 문자열을 가질때만 true를 리턴합니다. 이런 정보는 PCI bus 타입 코드와 같은 subsystem 
에 의해 사용되는데, 장치의 wakeup 메커니즘이 enable인지 disable 인지를 보기 위해서 이다. 만약 
장치의 wakeup 메커니즘이 드라이버에 의해서 바로 enable되거나 disable된다면, 이들은 시스템 sleep 
전이 시에 뭘할지 결정하기 위해 device_may_wakeup()을  이용해야 합니다. 그러나, 디바이스 드라이버는 
어떠한 경우에라도 device_set_wakeup_enable()을 호출하도록 돼 있지 않습니다.

It ought to be noted that system wakeup is conceptually different from "remote
wakeup" used by runtime power management, although it may be supported by the
same physical mechanism.  Remote wakeup is a feature allowing devices in
low-power states to trigger specific interrupts to signal conditions in which
they should be put into the full-power state.  Those interrupts may or may not
be used to signal system wakeup events, depending on the hardware design.  On
some systems it is impossible to trigger them from system sleep states.  In any
case, remote wakeup should always be enabled for runtime power management for
all devices and drivers that support it.

시스템 wakeup 은 개념상 runtime power management에 의해 사용되는 "remote wakeup"와 다르
다는 것을 숙지하셔야 합니다. 비록 같은 물리 메커니즘에 의해 지원될 수 있겠지만. Remote wakeup은 
저전력 상태에 있는 장치로 하여금 특정 인터럽트를 발생시키는 것을 가능하게 하는 기능 입니다. 이러한 
인터럽트들은 하드웨어 설계에 따라, 시스템 wakeup 이벤트 신호로 쓰일 수도 없을 수도 있습니다. 어떤
시스템에서는 시스템 슬립 상태에서 이러한 신호 트리거가 가능합니다. 어떤 경우라도, 원격 wakeup은 
지원하는 모든 장치와 드라이버를 위해 런타임 전력 관리를 항상 활성화 되어야 합니다. 

/sys/devices/.../power/control files
------------------------------------
Each device in the driver model has a flag to control whether it is subject to
runtime power management.  This flag, called runtime_auto, is initialized by the
bus type (or generally subsystem) code using pm_runtime_allow() or
pm_runtime_forbid(); the default is to allow runtime power management.



The setting can be adjusted by user space by writing either "on" or "auto" to
the device's power/control sysfs file.  Writing "auto" calls pm_runtime_allow(),
setting the flag and allowing the device to be runtime power-managed by its
driver.  Writing "on" calls pm_runtime_forbid(), clearing the flag, returning
the device to full power if it was in a low-power state, and preventing the
device from being runtime power-managed.  User space can check the current value
of the runtime_auto flag by reading the file.

The device's runtime_auto flag has no effect on the handling of system-wide
power transitions.  In particular, the device can (and in the majority of cases
should and will) be put into a low-power state during a system-wide transition
to a sleep state even though its runtime_auto flag is clear.

For more information about the runtime power management framework, refer to
Documentation/power/runtime_pm.txt.


Calling Drivers to Enter and Leave System Sleep States
======================================================
When the system goes into a sleep state, each device's driver is asked to
suspend the device by putting it into a state compatible with the target
system state.  That's usually some version of "off", but the details are
system-specific.  Also, wakeup-enabled devices will usually stay partly
functional in order to wake the system.

When the system leaves that low-power state, the device's driver is asked to
resume it by returning it to full power.  The suspend and resume operations
always go together, and both are multi-phase operations.

For simple drivers, suspend might quiesce the device using class code
and then turn its hardware as "off" as possible during suspend_noirq.  The
matching resume calls would then completely reinitialize the hardware
before reactivating its class I/O queues.

More power-aware drivers might prepare the devices for triggering system wakeup
events.


Call Sequence Guarantees
------------------------
To ensure that bridges and similar links needing to talk to a device are
available when the device is suspended or resumed, the device tree is
walked in a bottom-up order to suspend devices.  A top-down order is
used to resume those devices.

The ordering of the device tree is defined by the order in which devices
get registered:  a child can never be registered, probed or resumed before
its parent; and can't be removed or suspended after that parent.

The policy is that the device tree should match hardware bus topology.
(Or at least the control bus, for devices which use multiple busses.)
In particular, this means that a device registration may fail if the parent of
the device is suspending (i.e. has been chosen by the PM core as the next
device to suspend) or has already suspended, as well as after all of the other
devices have been suspended.  Device drivers must be prepared to cope with such
situations.


System Power Management Phases
시스템 전력 관리 상태
------------------------------
Suspending or resuming the system is done in several phases.  Different phases
are used for standby or memory sleep states ("suspend-to-RAM") and the
hibernation state ("suspend-to-disk").  Each phase involves executing callbacks
for every device before the next phase begins.  Not all busses or classes
support all these callbacks and not all drivers use all the callbacks.  The
various phases always run after tasks have been frozen and before they are
unfrozen.  Furthermore, the *_noirq phases run at a time when IRQ handlers have
been disabled (except for those marked with the IRQF_NO_SUSPEND flag).

시스템이 잠들거나 꺨 때 몇가지 상태(phase)에서 이루어 집니다. 각각의 다른 상태들은 standby 나 메
모리 슬립 상태("suspend-to-RAM") 그리고 하이버네이션 상태("suspend-to-RAM")를 위해 쓰입니다.
모든 bus나 class가 디런 콜백들을 지원하진 않으며 모든 드라이버가 모든 콜백을 쓰지도 않습니다. 여러
상태들은 항상 task가 frozen된 이후 그리고 task가 unfrozen되기 전에 동작합니다. 더욱이, 
*_noirq 상태들은 IRQ 핸들러가 비활성화 되었을 때 동작합니다. (IRQF_NO_SUSPEND 플래그로 마킹된
것들을 제외하고)

All phases use PM domain, bus, type, class or driver callbacks (that is, methods
defined in dev->pm_domain->ops, dev->bus->pm, dev->type->pm, dev->class->pm or
dev->driver->pm).  These callbacks are regarded by the PM core as mutually
exclusive.  Moreover, PM domain callbacks always take precedence over all of the
other callbacks and, for example, type callbacks take precedence over bus, class
and driver callbacks.  To be precise, the following rules are used to determine
which callback to execute in the given phase:

모든 상태들은 PM domain, bus, type, class 혹은 드라이버 콜백(dev->pm_domain->ops, 
dev->bus->pm, dev->type->pm, dev->class->pm 혹은 dev->driver->pm에 정의된 메소드들)을 
사용합니다.

    1.	If dev->pm_domain is present, the PM core will choose the callback
	included in dev->pm_domain->ops for execution

	1.	dev->pm_domain가 존재하면, PM core는 실행을 위해 dev->pm_domain->ops에 들어있는
	콜백을 선택합니다. 

    2.	Otherwise, if both dev->type and dev->type->pm are present, the callback
	included in dev->type->pm will be chosen for execution.

	2.	그렇지 않고, 만약 both dev->type와 dev->type->pm이 존재하면, 실행을 위해 
	dev->type->pm에 있는 콜백이 선택됩니다. 

    3.	Otherwise, if both dev->class and dev->class->pm are present, the
	callback included in dev->class->pm will be chosen for execution.

	3.	그렇지 않고, 만약 both dev->class와 dev->class->pm이 존재하면, 실행을 위해 
	dev->class->pm에 있는 콜백이 선택됩니다.

    4.	Otherwise, if both dev->bus and dev->bus->pm are present, the callback
	included in dev->bus->pm will be chosen for execution.

	4.	그렇지 않고, 만약 dev->bus와 dev->bus->pm are present가 모두 존재하면, 실행시 
	dev->bus->pm에 있는 콜백이 실행합니다. 

This allows PM domains and device types to override callbacks provided by bus
types or device classes if necessary.

The PM domain, type, class and bus callbacks may in turn invoke device- or
driver-specific methods stored in dev->driver->pm, but they don't have to do
that.

If the subsystem callback chosen for execution is not present, the PM core will
execute the corresponding method from dev->driver->pm instead if there is one.


Entering System Suspend
-----------------------
When the system goes into the standby or memory sleep state, the phases are:

		prepare, suspend, suspend_late, suspend_noirq.

    1.	The prepare phase is meant to prevent races by preventing new devices
	from being registered; the PM core would never know that all the
	children of a device had been suspended if new children could be
	registered at will.  (By contrast, devices may be unregistered at any
	time.)  Unlike the other suspend-related phases, during the prepare
	phase the device tree is traversed top-down.

	After the prepare callback method returns, no new children may be
	registered below the device.  The method may also prepare the device or
	driver in some way for the upcoming system power transition, but it
	should not put the device into a low-power state.

    2.	The suspend methods should quiesce the device to stop it from performing
	I/O.  They also may save the device registers and put it into the
	appropriate low-power state, depending on the bus type the device is on,
	and they may enable wakeup events.

    3	For a number of devices it is convenient to split suspend into the
	"quiesce device" and "save device state" phases, in which cases
	suspend_late is meant to do the latter.  It is always executed after
	runtime power management has been disabled for all devices.

    4.	The suspend_noirq phase occurs after IRQ handlers have been disabled,
	which means that the driver's interrupt handler will not be called while
	the callback method is running.  The methods should save the values of
	the device's registers that weren't saved previously and finally put the
	device into the appropriate low-power state.

	The majority of subsystems and device drivers need not implement this
	callback.  However, bus types allowing devices to share interrupt
	vectors, like PCI, generally need it; otherwise a driver might encounter
	an error during the suspend phase by fielding a shared interrupt
	generated by some other device after its own device had been set to low
	power.

At the end of these phases, drivers should have stopped all I/O transactions
(DMA, IRQs), saved enough state that they can re-initialize or restore previous
state (as needed by the hardware), and placed the device into a low-power state.
On many platforms they will gate off one or more clock sources; sometimes they
will also switch off power supplies or reduce voltages.  (Drivers supporting
runtime PM may already have performed some or all of these steps.)

If device_may_wakeup(dev) returns true, the device should be prepared for
generating hardware wakeup signals to trigger a system wakeup event when the
system is in the sleep state.  For example, enable_irq_wake() might identify
GPIO signals hooked up to a switch or other external hardware, and
pci_enable_wake() does something similar for the PCI PME signal.

If any of these callbacks returns an error, the system won't enter the desired
low-power state.  Instead the PM core will unwind its actions by resuming all
the devices that were suspended.


Leaving System Suspend
----------------------
When resuming from standby or memory sleep, the phases are:

		resume_noirq, resume_early, resume, complete.

    1.	The resume_noirq callback methods should perform any actions needed
	before the driver's interrupt handlers are invoked.  This generally
	means undoing the actions of the suspend_noirq phase.  If the bus type
	permits devices to share interrupt vectors, like PCI, the method should
	bring the device and its driver into a state in which the driver can
	recognize if the device is the source of incoming interrupts, if any,
	and handle them correctly.

	For example, the PCI bus type's ->pm.resume_noirq() puts the device into
	the full-power state (D0 in the PCI terminology) and restores the
	standard configuration registers of the device.  Then it calls the
	device driver's ->pm.resume_noirq() method to perform device-specific
	actions.

    2.	The resume_early methods should prepare devices for the execution of
	the resume methods.  This generally involves undoing the actions of the
	preceding suspend_late phase.

    3	The resume methods should bring the the device back to its operating
	state, so that it can perform normal I/O.  This generally involves
	undoing the actions of the suspend phase.

    4.	The complete phase should undo the actions of the prepare phase.  Note,
	however, that new children may be registered below the device as soon as
	the resume callbacks occur; it's not necessary to wait until the
	complete phase.

At the end of these phases, drivers should be as functional as they were before
suspending: I/O can be performed using DMA and IRQs, and the relevant clocks are
gated on.  Even if the device was in a low-power state before the system sleep
because of runtime power management, afterwards it should be back in its
full-power state.  There are multiple reasons why it's best to do this; they are
discussed in more detail in Documentation/power/runtime_pm.txt.

However, the details here may again be platform-specific.  For example,
some systems support multiple "run" states, and the mode in effect at
the end of resume might not be the one which preceded suspension.
That means availability of certain clocks or power supplies changed,
which could easily affect how a driver works.

Drivers need to be able to handle hardware which has been reset since the
suspend methods were called, for example by complete reinitialization.
This may be the hardest part, and the one most protected by NDA'd documents
and chip errata.  It's simplest if the hardware state hasn't changed since
the suspend was carried out, but that can't be guaranteed (in fact, it usually
is not the case).

Drivers must also be prepared to notice that the device has been removed
while the system was powered down, whenever that's physically possible.
PCMCIA, MMC, USB, Firewire, SCSI, and even IDE are common examples of busses
where common Linux platforms will see such removal.  Details of how drivers
will notice and handle such removals are currently bus-specific, and often
involve a separate thread.

These callbacks may return an error value, but the PM core will ignore such
errors since there's nothing it can do about them other than printing them in
the system log.


Entering Hibernation
--------------------
Hibernating the system is more complicated than putting it into the standby or
memory sleep state, because it involves creating and saving a system image.
Therefore there are more phases for hibernation, with a different set of
callbacks.  These phases always run after tasks have been frozen and memory has
been freed.

The general procedure for hibernation is to quiesce all devices (freeze), create
an image of the system memory while everything is stable, reactivate all
devices (thaw), write the image to permanent storage, and finally shut down the
system (poweroff).  The phases used to accomplish this are:

	prepare, freeze, freeze_late, freeze_noirq, thaw_noirq, thaw_early,
	thaw, complete, prepare, poweroff, poweroff_late, poweroff_noirq

    1.	The prepare phase is discussed in the "Entering System Suspend" section
	above.

    2.	The freeze methods should quiesce the device so that it doesn't generate
	IRQs or DMA, and they may need to save the values of device registers.
	However the device does not have to be put in a low-power state, and to
	save time it's best not to do so.  Also, the device should not be
	prepared to generate wakeup events.

    3.	The freeze_late phase is analogous to the suspend_late phase described
	above, except that the device should not be put in a low-power state and
	should not be allowed to generate wakeup events by it.

    4.	The freeze_noirq phase is analogous to the suspend_noirq phase discussed
	above, except again that the device should not be put in a low-power
	state and should not be allowed to generate wakeup events.

At this point the system image is created.  All devices should be inactive and
the contents of memory should remain undisturbed while this happens, so that the
image forms an atomic snapshot of the system state.

    5.	The thaw_noirq phase is analogous to the resume_noirq phase discussed
	above.  The main difference is that its methods can assume the device is
	in the same state as at the end of the freeze_noirq phase.

    6.	The thaw_early phase is analogous to the resume_early phase described
	above.  Its methods should undo the actions of the preceding
	freeze_late, if necessary.

    7.	The thaw phase is analogous to the resume phase discussed above.  Its
	methods should bring the device back to an operating state, so that it
	can be used for saving the image if necessary.

    8.	The complete phase is discussed in the "Leaving System Suspend" section
	above.

At this point the system image is saved, and the devices then need to be
prepared for the upcoming system shutdown.  This is much like suspending them
before putting the system into the standby or memory sleep state, and the phases
are similar.

    9.	The prepare phase is discussed above.

    10.	The poweroff phase is analogous to the suspend phase.

    11.	The poweroff_late phase is analogous to the suspend_late phase.

    12.	The poweroff_noirq phase is analogous to the suspend_noirq phase.

The poweroff, poweroff_late and poweroff_noirq callbacks should do essentially
the same things as the suspend, suspend_late and suspend_noirq callbacks,
respectively.  The only notable difference is that they need not store the
device register values, because the registers should already have been stored
during the freeze, freeze_late or freeze_noirq phases.


Leaving Hibernation
-------------------
Resuming from hibernation is, again, more complicated than resuming from a sleep
state in which the contents of main memory are preserved, because it requires
a system image to be loaded into memory and the pre-hibernation memory contents
to be restored before control can be passed back to the image kernel.

Although in principle, the image might be loaded into memory and the
pre-hibernation memory contents restored by the boot loader, in practice this
can't be done because boot loaders aren't smart enough and there is no
established protocol for passing the necessary information.  So instead, the
boot loader loads a fresh instance of the kernel, called the boot kernel, into
memory and passes control to it in the usual way.  Then the boot kernel reads
the system image, restores the pre-hibernation memory contents, and passes
control to the image kernel.  Thus two different kernels are involved in
resuming from hibernation.  In fact, the boot kernel may be completely different
from the image kernel: a different configuration and even a different version.
This has important consequences for device drivers and their subsystems.

To be able to load the system image into memory, the boot kernel needs to
include at least a subset of device drivers allowing it to access the storage
medium containing the image, although it doesn't need to include all of the
drivers present in the image kernel.  After the image has been loaded, the
devices managed by the boot kernel need to be prepared for passing control back
to the image kernel.  This is very similar to the initial steps involved in
creating a system image, and it is accomplished in the same way, using prepare,
freeze, and freeze_noirq phases.  However the devices affected by these phases
are only those having drivers in the boot kernel; other devices will still be in
whatever state the boot loader left them.

Should the restoration of the pre-hibernation memory contents fail, the boot
kernel would go through the "thawing" procedure described above, using the
thaw_noirq, thaw, and complete phases, and then continue running normally.  This
happens only rarely.  Most often the pre-hibernation memory contents are
restored successfully and control is passed to the image kernel, which then
becomes responsible for bringing the system back to the working state.

To achieve this, the image kernel must restore the devices' pre-hibernation
functionality.  The operation is much like waking up from the memory sleep
state, although it involves different phases:

	restore_noirq, restore_early, restore, complete

    1.	The restore_noirq phase is analogous to the resume_noirq phase.

    2.	The restore_early phase is analogous to the resume_early phase.

    3.	The restore phase is analogous to the resume phase.

    4.	The complete phase is discussed above.

The main difference from resume[_early|_noirq] is that restore[_early|_noirq]
must assume the device has been accessed and reconfigured by the boot loader or
the boot kernel.  Consequently the state of the device may be different from the
state remembered from the freeze, freeze_late and freeze_noirq phases.  The
device may even need to be reset and completely re-initialized.  In many cases
this difference doesn't matter, so the resume[_early|_noirq] and
restore[_early|_norq] method pointers can be set to the same routines.
Nevertheless, different callback pointers are used in case there is a situation
where it actually does matter.


Device Power Management Domains
-------------------------------
Sometimes devices share reference clocks or other power resources.  In those
cases it generally is not possible to put devices into low-power states
individually.  Instead, a set of devices sharing a power resource can be put
into a low-power state together at the same time by turning off the shared
power resource.  Of course, they also need to be put into the full-power state
together, by turning the shared power resource on.  A set of devices with this
property is often referred to as a power domain.

Support for power domains is provided through the pm_domain field of struct
device.  This field is a pointer to an object of type struct dev_pm_domain,
defined in include/linux/pm.h, providing a set of power management callbacks
analogous to the subsystem-level and device driver callbacks that are executed
for the given device during all power transitions, instead of the respective
subsystem-level callbacks.  Specifically, if a device's pm_domain pointer is
not NULL, the ->suspend() callback from the object pointed to by it will be
executed instead of its subsystem's (e.g. bus type's) ->suspend() callback and
anlogously for all of the remaining callbacks.  In other words, power management
domain callbacks, if defined for the given device, always take precedence over
the callbacks provided by the device's subsystem (e.g. bus type).

The support for device power management domains is only relevant to platforms
needing to use the same device driver power management callbacks in many
different power domain configurations and wanting to avoid incorporating the
support for power domains into subsystem-level callbacks, for example by
modifying the platform bus type.  Other platforms need not implement it or take
it into account in any way.


Device Low Power (suspend) States
---------------------------------
Device low-power states aren't standard.  One device might only handle
"on" and "off, while another might support a dozen different versions of
"on" (how many engines are active?), plus a state that gets back to "on"
faster than from a full "off".

Some busses define rules about what different suspend states mean.  PCI
gives one example:  after the suspend sequence completes, a non-legacy
PCI device may not perform DMA or issue IRQs, and any wakeup events it
issues would be issued through the PME# bus signal.  Plus, there are
several PCI-standard device states, some of which are optional.

In contrast, integrated system-on-chip processors often use IRQs as the
wakeup event sources (so drivers would call enable_irq_wake) and might
be able to treat DMA completion as a wakeup event (sometimes DMA can stay
active too, it'd only be the CPU and some peripherals that sleep).

Some details here may be platform-specific.  Systems may have devices that
can be fully active in certain sleep states, such as an LCD display that's
refreshed using DMA while most of the system is sleeping lightly ... and
its frame buffer might even be updated by a DSP or other non-Linux CPU while
the Linux control processor stays idle.

Moreover, the specific actions taken may depend on the target system state.
One target system state might allow a given device to be very operational;
another might require a hard shut down with re-initialization on resume.
And two different target systems might use the same device in different
ways; the aforementioned LCD might be active in one product's "standby",
but a different product using the same SOC might work differently.


Power Management Notifiers
전력 관리 통보
--------------------------
There are some operations that cannot be carried out by the power management
callbacks discussed above, because the callbacks occur too late or too early.
To handle these cases, subsystems and device drivers may register power
management notifiers that are called before tasks are frozen and after they have
been thawed.  Generally speaking, the PM notifiers are suitable for performing
actions that either require user space to be available, or at least won't
interfere with user space.

For details refer to Documentation/power/notifiers.txt.

자세한 정보는 Documentation/power/notifiers.txt를 참조하세요.

Runtime Power Management
런타임 전력 관리
========================
Many devices are able to dynamically power down while the system is still
running. This feature is useful for devices that are not being used, and
can offer significant power savings on a running system.  These devices
often support a range of runtime power states, which might use names such
as "off", "sleep", "idle", "active", and so on.  Those states will in some
cases (like PCI) be partially constrained by the bus the device uses, and will
usually include hardware states that are also used in system sleep states.

많은 장치들이 시스템이 여전히 동작 중인 동안에도 다이나믹하게 꺼질 수 있다. 이런 기능은 현재 
쓰이지 않고 있는 장치들에 유용하며, 시스템 동작중에 막대한 파워를 절약할 수 있다. 이런 장치들은
종종 많은 runtime power state를 지원하는데, 이들은 "off", "sleep", "idle", "active"
등과 같은 이름으로 쓰인다. 이런 state 들은 몇몇의 경우에는 (PCI와 같이) 부분적으로 해당 장치
가 사용하는 bus와 결합될 것이며, 보통은 시스템 sleep state에서도 사용되는 하드웨어 state를 
포함할 것이다.

A system-wide power transition can be started while some devices are in low
power states due to runtime power management.  The system sleep PM callbacks
should recognize such situations and react to them appropriately, but the
necessary actions are subsystem-specific.

system-wide power transition은 어떤 장치들이 runtime power management에 의해 
저전력 상태에 있는 동안 시작될 수 있습니다. system sleep PM 콜백들은 그런 상황들과 인지해서
적절히 반응해야 하지만, 필요한 행동은 subsystem에 특정 됩니다.  

In some cases the decision may be made at the subsystem level while in other
cases the device driver may be left to decide.  In some cases it may be
desirable to leave a suspended device in that state during a system-wide power
transition, but in other cases the device must be put back into the full-power
state temporarily, for example so that its system wakeup capability can be
disabled.  This all depends on the hardware and the design of the subsystem and
device driver in question.

어떤 경우에는 이것이 subsystem level에서 결정될 수 있으나 반면 어떤 경우에는 device driver
가 결정하지 않을 수 있다. 어떤 경우에는 system-wide power transition에 해당 state에 장치를 
맡겨 두는게 바람직 할 수도 있지만, 또 어떤 경우에는, 예를 들어 system wakeup 기능이 disable 
시킬 수 있도록 장치가 임시적으로 full-power 상태로 돌아가야 할 수도 있다. 

During system-wide resume from a sleep state it's easiest to put devices into
the full-power state, as explained in Documentation/power/runtime_pm.txt.  Refer
to that document for more information regarding this particular issue as well as
for information on the device runtime power management framework in general.

sleep 상태에서 system-wide resume 시, Documentation/power/runtime_pm.txt에서 설명한
대로, 장치를 full-power 상태로 만드는게 가장 쉽다. 이 특정 이슈에 대한 더 많은 정보와 일반적인 
runtime power management 프래임워크에 대한 정보를 위해서는 해당 문서를 참조하세요.
